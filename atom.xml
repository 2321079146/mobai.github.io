<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2321079146.github.io/mobai.github.io/</id>
    <title>墨白</title>
    <updated>2022-02-09T08:51:55.932Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2321079146.github.io/mobai.github.io/"/>
    <link rel="self" href="https://2321079146.github.io/mobai.github.io/atom.xml"/>
    <subtitle>芜湖，起飞</subtitle>
    <logo>https://2321079146.github.io/mobai.github.io/images/avatar.png</logo>
    <icon>https://2321079146.github.io/mobai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 墨白</rights>
    <entry>
        <title type="html"><![CDATA[Spring事务]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/spring-shi-wu/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/spring-shi-wu/">
        </link>
        <updated>2022-02-09T08:47:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="转载httpssnailclimbgiteeiojavaguidedocssystem-designframeworkspringspringe4ba8be58aa1e680bbe7bb93">转载：<a href="https://">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E4%BA%8B%E5%8A%A1%E6%80%BB%E7%BB%93</a></h2>
<br/>
<h1 id="1-基础介绍">1. 基础介绍</h1>
<p><strong>要么都执行，要么都不执行</strong></p>
<p><strong>注：事务是否生效取决于数据库引擎是否支持事务，比如mysql默认使用支持事务Innodb，但是数据库引擎变为myism，那么程序也不再支持事务</strong></p>
<br/>
<h1 id="2-事务特性acid">2. 事务特性【ACID】</h1>
<ul>
<li>原子性（Atomicity）： 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li>
<li>一致性（Consistency）： 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li>
<li>隔离性（Isolation）： 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>持久性（Durability）: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<br/>
<h1 id="3-详谈spring对事务支持">3. 详谈Spring对事务支持</h1>
<p><strong>问：mysql是怎么保证原子性?</strong></p>
<p>解：我们如果想要保证事务的原子性，就需要在异常发生的时候，对已经执行的操作进行<em>回滚</em>。在mysql中，恢复机制是通过*回滚日志（undo  log）*实现的。所有事务进行的修改都会先先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 回滚日志 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<h2 id="31-spring支持两种方式的事务管理">3.1 Spring支持两种方式的事务管理</h2>
<h3 id="311-编程式事务">3.1.1 编程式事务</h3>
<p><strong>1.使用TransactionTemplate 进行编程式事务管理的示例代码如下：</strong></p>
<pre><code class="language-java">@Autowired
private TransactionTemplate transactionTemplate;
public void testTransaction() {

        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) {

                try {

                    // ....  业务代码
                } catch (Exception e){
                    //回滚
                    transactionStatus.setRollbackOnly();
                }

            }
        });
}

</code></pre>
<br/>
<p><strong>2.使用 TransactionManager 进行编程式事务管理的示例代码如下：</strong></p>
<pre><code class="language-java">@Autowired
private PlatformTransactionManager transactionManager;

public void testTransaction() {

  TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());
          try {
               // ....  业务代码
              transactionManager.commit(status);
          } catch (Exception e) {
              transactionManager.rollback(status);
          }
}

</code></pre>
<br/>
<h3 id="312-声明式事务">3.1.2 声明式事务</h3>
<p>推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）。</p>
<br/>
<h2 id="32-spring事务管理接口介绍">3.2 Spring事务管理接口介绍</h2>
<p>Spring框架中，事务管理相关最重要的3个接口：</p>
<ol>
<li>PlatformTransactionManager：事务管理器，Spring事务策略的核心</li>
<li>TransactionDefinition：事务定义信息（事务隔离级别、传播行为、超时、只读、回滚规则）</li>
<li>TransactionStatus：事务运行状态</li>
</ol>
<p><strong>PlatformTransactionManager 会根据 TransactionDefinition 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 TransactionStatus 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</strong></p>
<br/>
<h3 id="321-platformtransactionmanager事务管理接口">3.2.1 PlatformTransactionManager事务管理接口</h3>
<p>Spring并不直接管理事务，而是提供了多种事务管理器。Spring事务管理器的接口：PlatformTransactionManager</p>
<p>通过这个接口，各个平台可以实现自身的管理器，例如：</p>
<ol>
<li>JDBC（DataSourceTransactionManager)</li>
<li>Hibernate(HibernateTransactionManager)</li>
<li>JPA(JpaTransactionManager)</li>
</ol>
<br/>
<p>示意图：</p>
<figure data-type="image" tabindex="1"><img src="https://2321079146.github.io/mobai.github.io//post-images/1644396676249.png" alt="" loading="lazy"></figure>
<br/>
<p>PlatformTransactionManager 接口中定义三个方法：</p>
<pre><code class="language-java">package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface PlatformTransactionManager {
    //获得事务
    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;
    //提交事务
    void commit(TransactionStatus var1) throws TransactionException;
    //回滚事务
    void rollback(TransactionStatus var1) throws TransactionException;
}
</code></pre>
<br/>
<h2 id="322-transactiondefinition属性">3.2.2 TransactionDefinition属性</h2>
<p>事务属性共包含五个方面</p>
<ol>
<li>隔离级别</li>
<li>传播行为</li>
<li>回滚规则</li>
<li>是否只读</li>
<li>事务超时</li>
</ol>
<br/>
<p><strong>源码：</strong></p>
<pre><code class="language-java">package org.springframework.transaction;

import org.springframework.lang.Nullable;

public interface TransactionDefinition {
    int PROPAGATION_REQUIRED = 0;
    int PROPAGATION_SUPPORTS = 1;
    int PROPAGATION_MANDATORY = 2;
    int PROPAGATION_REQUIRES_NEW = 3;
    int PROPAGATION_NOT_SUPPORTED = 4;
    int PROPAGATION_NEVER = 5;
    int PROPAGATION_NESTED = 6;
    int ISOLATION_DEFAULT = -1;
    int ISOLATION_READ_UNCOMMITTED = 1;
    int ISOLATION_READ_COMMITTED = 2;
    int ISOLATION_REPEATABLE_READ = 4;
    int ISOLATION_SERIALIZABLE = 8;
    int TIMEOUT_DEFAULT = -1;
    // 返回事务的传播行为，默认值为 REQUIRED。
    int getPropagationBehavior();
    //返回事务的隔离级别，默认值是 DEFAULT
    int getIsolationLevel();
    // 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。
    int getTimeout();
    // 返回是否为只读事务，默认值为 false
    boolean isReadOnly();

    @Nullable
    String getName();
}

</code></pre>
<br/>
<h2 id="323-transactionstatus事务状态">3.2.3 TransactionStatus事务状态</h2>
<p>PlatformTransactionManager.getTransaction(…)方法返回一个 TransactionStatus 对象。</p>
<pre><code class="language-java">public interface TransactionStatus{
    boolean isNewTransaction(); // 是否是新的事务
    boolean hasSavepoint(); // 是否有恢复点
    void setRollbackOnly();  // 设置为只回滚
    boolean isRollbackOnly(); // 是否为只回滚
    boolean isCompleted; // 是否已完成
}
</code></pre>
<br/>
<h1 id="33-事务属性详解">3.3 事务属性详解</h1>
<p>实际开发业务中，大家一般都是使用*@Transactional*注解来开启事务的，但是很多人并不清楚里面的参数有什么意思，有什么用。</p>
<h2 id="331-事务传播行为">3.3.1 事务传播行为</h2>
<p><strong>源码：</strong></p>
<pre><code class="language-java">package org.springframework.transaction.annotation;

import org.springframework.transaction.TransactionDefinition;

public enum Propagation {

    REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED),

    SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS),

    MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY),

    REQUIRES_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW),

    NOT_SUPPORTED(TransactionDefinition.PROPAGATION_NOT_SUPPORTED),

    NEVER(TransactionDefinition.PROPAGATION_NEVER),

    NESTED(TransactionDefinition.PROPAGATION_NESTED);


    private final int value;

    Propagation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }

}

</code></pre>
<br/>
<p><strong>事务传播行为解析：</strong></p>
<ol>
<li>TransactionDefinition.PROPAGATION_REQUIRED【默认】：如果当前有事务，则加入该事务，如果当前没有事务，则创建一个事务</li>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：不管当前有没有事务，直接开启新事务，相互之前没有影响</li>
<li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED<br>
例：a方法包含b1(NESTED)，b2(NESTED)方法，a回滚则全部回滚，b1回滚并不会造成b2和a回滚</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
<li>TransactionDefinition.SUPPORTS：支持当前事务，若当前不存在事务，就以非事务运行</li>
<li>TransactionDefinition.NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则挂起</li>
<li>Transactiondefinition.NEVER：以非事务方式运行，若当前存在事务则抛出异常</li>
</ol>
<br/>
<h2 id="332-事务隔离级别">3.3.2 事务隔离级别</h2>
<ol>
<li>TransactionDefinition.ISOLATION_DEFAULT :使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ 隔离级别 Oracle 默认采用的 READ_COMMITTED 隔离级别.</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED : 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ol>
<br/>
<p><strong>InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。</strong></p>
<br/>
<h3 id="3321-不考虑隔离性会发生什么样的问题呢">3.3.2.1 不考虑隔离性，会发生什么样的问题呢？</h3>
<ol>
<li>
<p>脏读：指一个事务在处理数据的过程中，读取到另一个未提交事务的数据。</p>
</li>
<li>
<p>不可重复读：对应数据库的某个数据，一个事务范围内的多次查询却返回了不同的结果，这是由于在查询过程中，数据被另一个事务修改并提交。</p>
</li>
<li>
<p>幻读：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p>
<p><em>不可重复读和幻读是初学者不易分清的概念，我也是看了详细的解读才明白的，总的来说，解决不可重复读的方法是 锁行，解决幻读的方式是 锁表。</em></p>
</li>
</ol>
<br/>
<h3 id="3322-四种隔离级别解决上述问题">3.3.2.2 四种隔离级别解决上述问题</h3>
<ol>
<li>
<p>读未提交（Read uncommitted）：这种事务隔离级别下，select语句不加锁。</p>
<p>此时，可能读取到不一致的数据，即“读脏 ”。这是并发最高，一致性最差的隔离级别。</p>
</li>
<li>
<p>读已提交（Read committed）：可避免 脏读 的发生。</p>
<p>在互联网大数据量，高并发量的场景下，几乎 不会使用 上述两种隔离级别。</p>
</li>
<li>
<p>可重复读（Repeatable read）：MySql默认隔离级别。可避免 脏读 、不可重复读 的发生。</p>
</li>
<li>
<p>串行化（Serializable ）：可避免 脏读、不可重复读、幻读 的发生。</p>
</li>
</ol>
<br/>
<p>以上四种隔离级别最高的是 Serializable 级别，最低的是 Read uncommitted 级别，当然级别越高，执行效率就越低。像 Serializable 这样的级别，就是以 锁表 的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读) 。</p>
<p>在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读) ；而在 Oracle数据库 中，只支持Serializable (串行化) 级别和 Read committed (读已提交) 这两种级别，其中默认的为 Read committed（读已提交） 级别。</p>
<br/>
<h3 id="3323-查看数据库隔离级别">3.3.2.3 查看数据库隔离级别</h3>
<pre><code class="language-sql">MySQL
mysql默认的事务处理级别是'REPEATABLE-READ',也就是可重复读
1.查看当前会话隔离级别
select @@tx_isolation;
2.查看系统当前隔离级别
select @@global.tx_isolation;
3.设置当前会话隔离级别
set session transaction isolatin level repeatable read;
4.设置系统当前隔离级别
set global transaction isolation level repeatable read;
Oracle
oracle数据库支持READ COMMITTED 和 SERIALIZABLE这两种事务隔离级别。
默认系统事务隔离级别是READ COMMITTED,也就是读已提交
1.查看系统默认事务隔离级别,也是当前会话隔离级别
--首先创建一个事务
declare
     trans_id Varchar2(100);
  begin
     trans_id := dbms_transaction.local_transaction_id( TRUE );
  end; 
--查看事务隔离级别
SELECT s.sid, s.serial#,
　　CASE BITAND(t.flag, POWER(2, 28))
　　　　WHEN 0 THEN 'READ COMMITTED'
　　　　ELSE 'SERIALIZABLE'
　　END AS isolation_level
FROM v$transaction t
JOIN v$transactiontJOINvtransaction t
JOIN v
transactiontJOINvsession s ON t.addr = s.taddr AND s.sid = sys_context('USERENV', 'SID');
</code></pre>
<br/>
<h2 id="333-事务超时属性">3.3.3 事务超时属性</h2>
<p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒，默认值为-1。</p>
<br/>
<h2 id="334-事务只读属性">3.3.4 事务只读属性</h2>
<p><strong>1. 概念：</strong></p>
<p>从这一点设置的时间点开始（时间点a）到这个事务结束的过程中，其他事务所提交的数据，该事务将看不见！（查询中不会出现别人在时间点a之后提交的数据）</p>
<br/>
<p><strong>2. 应用场合：</strong></p>
<ol>
<li>如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持sql执行期间的读一致性</li>
<li>如果你一次执行多条查询语句，例如统计查询、报表查询，多条的查询sql必须保持一致性，否则，在前条sql查询之后，数据被其他用户改变，则该次的统计查询会出现读数据不一致的状态，此时应启动事务支持</li>
</ol>
<br/>
<p><strong>3. 如何设置：</strong></p>
<p>对于只读查询，可以指定事务类型为readonly，即只读事务。<br>
由于只读事务不存在数据的修改，因此数据库将会为只读事务提供一些优化手段，例如Oracle对于只读事务，不启动回滚段，不记录回滚log。</p>
<p>（1）在JDBC中，指定只读事务的办法为： connection.setReadOnly(true);</p>
<p>（2）在Hibernate中，指定只读事务的办法为： session.setFlushMode(FlushMode.NEVER);<br>
此时，Hibernate也会为只读事务提供Session方面的一些优化手段</p>
<p>（3）在Spring的Hibernate封装中，指定只读事务的办法为： bean配置文件中，prop属性增加“readOnly”<br>
或者用注解方式@Transactional(readOnly=true)<br>
【 if the transaction is marked as read-only, Spring will set the Hibernate Session’s flush mode to FLUSH_NEVER,<br>
and will set the JDBC transaction to read-only】也就是说在Spring中设置只读事务是利用上面两种方式</p>
<br/>
<h2 id="335-事务回滚规则">3.3.5 事务回滚规则</h2>
<p>这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下事务只有遇到运行时异常（RuntimeException）时才会回滚，Error也会导致事务回滚，但是遇到检查型异常（Checked）不会回滚。</p>
<p>如果你想要回滚你定义的特定的异常类型的话，可以这样：</p>
<pre><code class="language-java">@Transactional(rollbackFor= MyException.class)
</code></pre>
<br/>
<h1 id="34-transactional">3.4 @Transactional</h1>
<h3 id="341-transactional-作用范围">3.4.1 @Transactional 作用范围</h3>
<ol>
<li>方法：推荐将注解使用于方法上，不过需要注意的是该注解只能应用到public方法上，否则不生效</li>
<li>类：如果这个注解使用在类上，表示该注解对类中所有的public生效</li>
<li>接口：不推荐在接口上使用</li>
</ol>
<br/>
<h3 id="342-transactional-常用参数">3.4.2 @Transactional 常用参数</h3>
<p>@Transactional注解源码</p>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Inherited
@Documented
public @interface Transactional {

    @AliasFor(&quot;transactionManager&quot;)
    String value() default &quot;&quot;;

    @AliasFor(&quot;value&quot;)
    String transactionManager() default &quot;&quot;;

    Propagation propagation() default Propagation.REQUIRED;

    Isolation isolation() default Isolation.DEFAULT;

    int timeout() default TransactionDefinition.TIMEOUT_DEFAULT;

    boolean readOnly() default false;

    Class&lt;? extends Throwable&gt;[] rollbackFor() default {};

    String[] rollbackForClassName() default {};

    Class&lt;? extends Throwable&gt;[] noRollbackFor() default {};

    String[] noRollbackForClassName() default {};

}

</code></pre>
<br/>
<p><strong>属性说明</strong></p>
<figure data-type="image" tabindex="2"><img src="https://2321079146.github.io/mobai.github.io//post-images/1644396708283.png" alt="" loading="lazy"></figure>
<br/>
<h3 id="343-transactional-事务注解原理">3.4.3 @Transactional 事务注解原理</h3>
<p>@Transactional 的工作机制是基于 AOP 实现的，AOP又是使用动态代理实现的，如果目标对象默认使用JDK的动态代理，如果目标对象没有实现接口会使用CGLIB动态代理</p>
<br/>
<p>createAopProxy() 方法 决定了是使用 JDK 还是 Cglib 来做动态代理，源码如下：</p>
<pre><code class="language-java">public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {

    @Override
    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
            Class&lt;?&gt; targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                        &quot;Either an interface or a target is required for proxy creation.&quot;);
            }
            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
                return new JdkDynamicAopProxy(config);
            }
            return new ObjenesisCglibAopProxy(config);
        }
        else {
            return new JdkDynamicAopProxy(config);
        }
    }
  .......
}

</code></pre>
<br/>
<p>如果一个类或者一个类中的public方法上被标注@Transactional注解的话，Spring容器就会在启动的时候为其创建一个代理类，在调用@Transactional注解的public方法的时候，实际调用的是TransactionInterceptor类中的invoke()方法，这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务。</p>
<br/>
<blockquote>
<p>TransactionInterceptor 类中的 invoke()方法内部实际调用的是 TransactionAspectSupport 类的 invokeWithinTransaction()方法。</p>
</blockquote>
<br/>
<h3 id="343-spring-aop-自调用问题">3.4.3 Spring AOP 自调用问题</h3>
<p>若同一类中的其他没有@Transactional注解的方法内部调用有@Transactional注解的方法，有@Transactional注解的方法的事务会失效</p>
<p>这是由于Spring Aop代理的原因导致的，因为只用当@Transactional注解方法在类以外被调用的时候，Spring 事务管理才生效。</p>
<br/>
<h3 id="345-transactional的使用注意事项总结">3.4.5 @Transactional的使用注意事项总结</h3>
<ol>
<li>@Transactional 注解只有作用到public方法上事务才会生效，不推荐在接口上使用</li>
<li>避免同一个类中调用@Transactional 注解的方法，这样会导致事务失效</li>
<li>正确的设置 @Transactional 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失效</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[barcode4j生成条形码，zxing生成二维码，zxing识别，itextpdf增加至pdf中]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/barcode4j-sheng-cheng-tiao-xing-ma-zxing-sheng-cheng-er-wei-ma-zxing-shi-bie-itextpdf-zeng-jia-zhi-pdf-zhong/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/barcode4j-sheng-cheng-tiao-xing-ma-zxing-sheng-cheng-er-wei-ma-zxing-shi-bie-itextpdf-zeng-jia-zhi-pdf-zhong/">
        </link>
        <updated>2022-01-28T01:44:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">package osj.web.util;

import com.google.zxing.*;
import com.google.zxing.client.j2se.BufferedImageLuminanceSource;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.common.HybridBinarizer;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.pdf.ColumnText;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfWriter;
import org.apache.commons.lang3.StringUtils;
import org.krysalis.barcode4j.impl.code128.Code128Bean;
import org.krysalis.barcode4j.impl.code128.Code128Constants;
import org.krysalis.barcode4j.output.bitmap.BitmapCanvasProvider;
import org.krysalis.barcode4j.tools.UnitConv;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import osj.web.exception.BusinessException;

import javax.imageio.ImageIO;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.zip.ZipOutputStream;

/**
 * @Author: mxc
 * @Date: 2021-08-09
 * @Description: 二维码工具类
 */
public class BarcodeUtil {

    private static final Logger logger = LoggerFactory.getLogger(BarcodeUtil.class);

    /**
     * itextpdf 创建Pdf
     * @param sku sku信息
     * @param skuFilePath sku保存路径
     */
    public static String createBarcodePdf(String sku, String skuFilePath){
        if (StringUtils.isBlank(sku)) {
            return null;
        }
        String newFilePath = skuFilePath + sku + &quot;.pdf&quot;;
        try {
            File mkdir = new File(skuFilePath);
            if (!mkdir.exists()) {
                if (!mkdir.mkdirs()) {
                    throw new BusinessException(&quot;目录创建失败&quot;);
                }
            }
            FileOutputStream out = new FileOutputStream(newFilePath);
            // Step 1—Create a Document.
            com.itextpdf.text.Rectangle pageSize = new com.itextpdf.text.Rectangle(328, 125);
            Document document = new Document(pageSize);
            // Step 2—Get a PdfWriter instance.
            PdfWriter pdfWriter = PdfWriter.getInstance(document, out);
            // Step 3—Open the Document.
            document.open();
            // PdfContentByte cb = new PdfContentByte(pdfWriter); document直接添加元素使用这个
            PdfContentByte cb = pdfWriter.getDirectContent();

            // 生成code128A条形码
            String code128Image = createSkuCode128A(sku, skuFilePath);
            // 生成二维码
            String qrCode = createSkuQrCode(sku, skuFilePath);

            if (StringUtils.isEmpty(code128Image) || StringUtils.isEmpty(qrCode)) {
                throw new BusinessException(&quot;二维码或者条形码图片生成失败&quot;);
            }

            // 将生成的图片添加到pdf中
            imageAddToPdf(cb, document, code128Image, qrCode, sku);

            // Step 4—Close the Document.
            document.close();
            out.close();

            // 删除图片临时文件
            File codeFile = new File(code128Image);
            if (codeFile.exists()) {
                if (!codeFile.delete()) {
                    throw new BusinessException(&quot;条形码图片删除失败&quot;);
                }
            }

            File qrCodeFile = new File(qrCode);
            if (qrCodeFile.exists()) {
                if (!qrCodeFile.delete()) {
                    throw new BusinessException(&quot;二维码图片删除失败&quot;);
                }
            }
        }catch (Exception e) {
            logger.error(&quot;创建skuPdf失败&quot;,e);
        }
        return newFilePath;
    }

    /**
     * 将图片添加到pdf中
     * @param document document
     * @param code128Image 条形码图片路径
     * @param qrCode 二维码图片路径
     * @param sku sku
     * @throws DocumentException document异常
     * @throws IOException io异常
     */
    private static void imageAddToPdf(PdfContentByte cb, Document document,String code128Image, String qrCode, String sku) throws Exception {

        com.itextpdf.text.Image code128ImageFile = com.itextpdf.text.Image.getInstance(code128Image);

        int qrCodeWith = 90;

        int codeWidth = 200;

        int codeHeight = 30;

        String str = &quot;PJ&quot;;
        // 配件sku增加标识
        if (sku.startsWith(str)) {
            // 文本框位置
            com.itextpdf.text.Rectangle rect = new com.itextpdf.text.Rectangle(165, 120, 85, 60);
            ColumnText cts = new ColumnText(cb);
            cts.addText(new Phrase(&quot;** PJ **&quot;));
            cts.setSimpleColumn(rect);
            cts.go();
        }
        code128ImageFile.setWidthPercentage(100);
        code128ImageFile.setAbsolutePosition(0, 40);
        code128ImageFile.scaleToFit(220,40 + codeHeight);
        String code128Str = imageDecode(code128Image);
        if (!sku.equals(code128Str)) {
            logger.error(&quot;sku:&quot; + sku + &quot;|&quot; + &quot;条形码:&quot; + code128Str);
            throw new BusinessException(&quot;条形码识别信息与sku不匹配&quot;);
        }

        // 文本框位置
        com.itextpdf.text.Rectangle rect = new com.itextpdf.text.Rectangle(65, 35, 180, 15);
        ColumnText cts = new ColumnText(cb);
        cts.addText(new Phrase(sku));
        cts.setSimpleColumn(rect);
        cts.go();

        cb.addImage(code128ImageFile);

        com.itextpdf.text.Image qrCodeImageFile = com.itextpdf.text.Image.getInstance(qrCode);
        qrCodeImageFile.setAbsolutePosition(200, 0);
        code128ImageFile.scaleToFit(230 + qrCodeWith,qrCodeWith + 20);
        String qrCodeStr = imageDecode(code128Image);
        if (!sku.equals(qrCodeStr)) {
            logger.error(&quot;sku:&quot; + sku + &quot;|&quot; + &quot;二维码:&quot; + code128Str);
            throw new BusinessException(&quot;二维码识别信息与sku不匹配&quot;);
        }
        cb.addImage(qrCodeImageFile);
    }

    /**
     * 使用zxing生成二维码
     * barcode4j现无二维码编辑器
     * 官方文档解释：Barcode4J does not currently contain an actual QR Code encoder. The QR Code support is currently just an adapter to ZXing's QR encoder.
     *            This means that ZXing Core 1.7 (or later) has to be in the classpath for this to work.
     *            Barcode4J may get its own QR Code encoder sometime in the future.
     * @param sku sku
     * @param skuPath 基础路径
     * @return 新文件路径
     * @throws FileNotFoundException 文件找不到异常
     */
    private static String createSkuQrCode(String sku, String skuPath) throws FileNotFoundException, WriterException {
        String newFilePath = skuPath + sku + &quot;_2.png&quot;;

        try {
            BitMatrix bitMatrix = new MultiFormatWriter().encode(sku,
                    BarcodeFormat.QR_CODE, 120, 120, null);

            Path path = new File(newFilePath).toPath();
            MatrixToImageWriter.writeToPath(bitMatrix, &quot;png&quot;,path);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return newFilePath;
    }

    /**
     *
     * barcode4j生成code128A条形码
     * @param sku sku
     * @param skuPath 基础路径
     * @return 新路径
     * @throws FileNotFoundException 文件未找到
     */
    private static String createSkuCode128A(String sku, String skuPath) throws FileNotFoundException {
        String newFilePath = skuPath + sku + &quot;_1.png&quot;;
        File file = new File(newFilePath);
        OutputStream out = new FileOutputStream(file);
        if (StringUtils.isEmpty(sku)) {
            return null;
        }

        Code128Bean bean = new Code128Bean();
        // 精细度
        final int dpi = 400;
        // module宽度
        final double moduleWidth = UnitConv.in2mm(1.0f / dpi);

        // 配置图片相关属性
        bean.setBarHeight(4);
        // 只能使用code128A生成
        bean.setCodeset(Code128Constants.CODESET_A);
        bean.setModuleWidth(moduleWidth);
        // 左右是否留空
        bean.doQuietZone(true);
        // 底部字体的大小
        bean.setFontSize(0);
        String format = &quot;image/png&quot;;

        try {
            BitmapCanvasProvider canvas = new BitmapCanvasProvider(out, format, dpi,
                    BufferedImage.TYPE_BYTE_BINARY, false, 0);
            // 生成条形码
            bean.generateBarcode(canvas, sku);
            // 完成绘制
            canvas.finish();
            out.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return newFilePath;
    }

    /**
     * zxing识别图形中包含信息
     *
     * @throws IOException io异常
     */
    public static String imageDecode(String filePath) throws Exception {
        BufferedImage image;
        Result result = null;
        try {
            image = ImageIO.read(new File(filePath));
            if (image == null) {
                throw new BusinessException(&quot;图片不存在或者创建失败&quot;);
            }
            LuminanceSource source = new BufferedImageLuminanceSource(image);
            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));

            result = new MultiFormatReader().decode(bitmap, null);
            return result.getText();
        } catch (Exception e) {
            e.printStackTrace();
        }
        if (result == null) {
            throw new BusinessException(&quot;图片识别异常&quot;);
        }
        return null;
    }


    /**
     * 校验sku
     *
     * @param skuName sku名称
     * @return 是否正确
     */
    public static boolean isValid(String skuName) {
        String regex = &quot;^[a-zA-Z]{2}[0-9]{6}[a-zA-Z]{3}$&quot;;
        skuName = skuName.toUpperCase().trim();
        if (StringUtils.isBlank(skuName) || !skuName.matches(regex)) {
            System.out.println(&quot;请输入正确的SKU&quot;);
            return false;
        }

        return true;
    }

    /**
     * 单个文件下载
     *
     * @param fileName 文件名
     * @param type     二维码尺寸类型
     * @return 校验信息
     */
    public static String doDownLoad(HttpServletRequest request, HttpServletResponse response, String fileName, int type) {
        String requestUrl = request.getSession().getServletContext().getRealPath(&quot;/&quot;);
        String filePath = requestUrl + &quot;barcode/&quot; + fileName + &quot;.pdf&quot;;
        File file = new File(filePath);

        if (!isValid(fileName)) {
            return &quot;SKU格式不规范&quot;;
        }

        // 文件存在则直接获取文件,若不存在则需要下载
        if (!file.exists()) {
            createBarcodePdf(fileName, requestUrl + &quot;barcode/&quot;);
        }
        return null;
    }

    /**
     * 批量文件zip下载
     *
     * @param skuCodes 文件名
     * @param type     二维码尺寸类型
     * @return 校验信息
     */
    public static String batchDownLoad(HttpServletRequest request, HttpServletResponse response, List&lt;String&gt; skuCodes, int type) {
        String requestUrl = request.getSession().getServletContext().getRealPath(&quot;/&quot;);

        // 获取校验通过的文件【前端已校验格式】
        List&lt;File&gt; files = new ArrayList&lt;&gt;();
        for (String skuCode : skuCodes) {
            String filePath = requestUrl + &quot;barcode/&quot; + skuCode + &quot;.pdf&quot;;
            File file = new File(filePath);
            // 文件存在则直接获取文件,若不存在则需要下载
            if (!file.exists()) {
                createBarcodePdf(skuCode,  requestUrl + &quot;barcode/&quot;);
                file = new File(filePath);
            }
            files.add(file);
        }

        Date currentDate = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);
        String currentTime = sdf.format(currentDate);
        // 遍历文件存入到zip文件中
        String zip = currentTime + &quot;.zip&quot;;
        File fileZip = new File(requestUrl + &quot;download/&quot; + zip);
        // 文件输出流
        FileOutputStream outStream = null;
        ZipOutputStream toClient = null;
        try {
            outStream = new FileOutputStream(fileZip);
            // 压缩流
            toClient = new ZipOutputStream(outStream);
            // 存入到本地服务器中
            FileAddToZipUtil.zipFile(files, toClient);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (toClient != null) {
                    toClient.flush();
                    toClient.close();
                }
                if (outStream != null) {
                    outStream.flush();
                    outStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return zip;
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spire创建code128A和条形码]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/spire-chuang-jian-code128a-he-tiao-xing-ma/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/spire-chuang-jian-code128a-he-tiao-xing-ma/">
        </link>
        <updated>2022-01-28T01:42:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="代码展示">代码展示</h2>
<pre><code class="language-java">    /**
     * 创建二维码
     *
     * @param sku         sku名称
     * @param skuFilePath 文件保存地址
     * @param type        二维码类型
     * @return 文件保存路径
     */
    public static String createPdf(String sku, String skuFilePath, int type) {
        if (StringUtils.isBlank(sku)) {
            return null;
        }

        int pdfWidth, pdfHeight;
        float qrWidth;
        double barcodeWidth, barcodeHeight;
        int fontsize;
        float leftMargin, topMargin;

        if (type == OsjConstant.BARCODE_COMMON) {// 普通版本
            pdfWidth = 308;
            pdfHeight = 105;
            qrWidth = 93;
            barcodeWidth = 190;
            barcodeHeight = 65;
            fontsize = 26;
            leftMargin = 6;
            topMargin = 6;
        } else if (type == OsjConstant.BARCODE_BIG_WIDTH) {// 大边距普通版本
            // pdf页面宽度
            pdfWidth = 328;
            // PDF页面高度
            pdfHeight = 125;
            // 二维码尺寸
            qrWidth = 90;
            // 条形码宽度
            barcodeWidth = 180;
            // 条形码高度
            barcodeHeight = 65;
            // 条形码下面的字的尺寸
            fontsize = 15;
            // 条形码离左侧的距离
            leftMargin = 16;
            // 条形码离上面的距离
            topMargin = 16;
        } else {// 条码宽版本
            pdfWidth = 328;
            pdfHeight = 105;
            qrWidth = 93;
            barcodeWidth = 210;
            barcodeHeight = 62;
            fontsize = 29;
            leftMargin = 6;
            topMargin = 6;
        }

        //创建PdfDocument对象
        PdfDocument doc = new PdfDocument();
        Dimension2D pdfSize = new Dimension(pdfWidth, pdfHeight);
        PdfMargins margins = new PdfMargins(leftMargin, topMargin);
        //添加一页
        PdfPageBase page = doc.getPages().add(pdfSize, margins);
        page.setBackgroudOpacity(0);
        //初始化y变量
        double y = 0;

        // 配件sku需增加字符串显示
        final String partsStr = &quot;PJ&quot;;
        if (sku.startsWith(partsStr)) {
            y = 35;
            barcodeHeight = 30;
            Point2D.Float pointPJ = new Point2D.Float();
            pointPJ.setLocation(50,1);
            page.getCanvas().drawString(&quot;** PARTS **&quot;, new PdfTrueTypeFont(new Font(&quot;Arial&quot;, Font.BOLD, fontsize), true),
                    new PdfSolidBrush(new PdfRGBColor(Color.black)), pointPJ);
        }

        Point2D.Float point = new Point2D.Float();
        point.setLocation(0, y);

        // 绘制Code128A条码到PDF
        BarcodeSettings settingsCode = new BarcodeSettings();
        // 设置条形码类型
        settingsCode.setType(BarCodeType.Code_128);
        // code128a
        settingsCode.setCode128SetMode(Code128SetMode.Only_A);
        // 设置条形码数据
        settingsCode.setData(sku);
        // 不显示文本
        settingsCode.setShowText(false);
        //在底部显示数据
        settingsCode.setShowTextOnBottom(true);
        //设置边框为不可见
        settingsCode.hasBorder(false);
        BarCodeGenerator generator = new BarCodeGenerator(settingsCode);

        Rectangle2D rect = new Rectangle();
        rect.setRect(point.x, y, barcodeWidth, barcodeHeight);
        //draw
        PdfImage pdfImage1 = PdfImage.fromImage(generator.generateImage());
        page.getCanvas().drawImage(pdfImage1, rect);

        y = y + barcodeHeight + 5;

        //-------创建字体---
        //location
        Point2D.Float pointW = new Point2D.Float();
        pointW.setLocation(45, y);
        //设置字体
        PdfTrueTypeFont font1 = new PdfTrueTypeFont(new Font(&quot;Arial&quot;, Font.BOLD, fontsize), true);
        for (int i = 1; i &lt; 10; i++) {
            Dimension2D tSize = font1.measureString(sku);
            System.out.println(tSize.getWidth());
            if (tSize.getWidth() &gt; (barcodeWidth - 1)) {
                fontsize = fontsize - 1;
                font1 = new PdfTrueTypeFont(new Font(&quot;Aria&quot;, Font.BOLD, fontsize), true);
            } else {
                break;
            }
        }
        //draw
        PdfSolidBrush brush = new PdfSolidBrush(new PdfRGBColor(Color.black));
        page.getCanvas().drawString(sku, font1, brush, pointW);

        //创建BarcodeSettings实例----------------------------------------------
        BarcodeSettings settings = new BarcodeSettings();
        //设置条码类型为QR二维码
        settings.setType(BarCodeType.QR_Code);
        //设置二维码数据
        settings.setData(sku);
        //设置二维码显示数据
        settings.setData2D(null);
        //设置数据类型
        settings.setQRCodeDataMode(QRCodeDataMode.Alpha_Number);
        //设置二维码纠错级别
        settings.setQRCodeECL(QRCodeECL.H);
        settings.setShowText(false);
        settings.setTopMargin(0);
        settings.setLeftMargin(0);
        settings.setRightMargin(0);
        settings.setBottomMargin(0);

        //创建BarCodeGenerator实例
        BarCodeGenerator barCodeGenerator = new BarCodeGenerator(settings);
        //根据settings生成图像数据，保存至BufferedImage实例
        BufferedImage bufferedImage = barCodeGenerator.generateImage();
        //绘制二维码图片到PDF页面指定位置
        PdfImage pdfImage = PdfImage.fromImage(bufferedImage);
        Rectangle2D rect2 = new Rectangle();
        rect2.setRect(barcodeWidth * 1.06, 0, qrWidth, qrWidth);
        page.getCanvas().drawImage(pdfImage, rect2);

        //check
        //--------------
        try {
            String[] dataArr = BarcodeScanner.scan(page.extractImages()[0], BarCodeType.Code_128);
            logger.info(Arrays.toString(dataArr) + &quot;  | &quot; + sku);
            if (dataArr.length == 0) {
                throw new OsjException(&quot;无法读取条码&quot;);
            }
            String nullStr = &quot;null&quot;;
            if (dataArr[0] == null || nullStr.equals(dataArr[0]) || !sku.equals(dataArr[0])) {
                throw new OsjException(&quot;无法读取条码&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        //----------------


        //保存PDF文档
        doc.saveToFile(skuFilePath);
        return skuFilePath;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot 配置动态定时任务]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/spring-boot-pei-zhi-dong-tai-ding-shi-ren-wu/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/spring-boot-pei-zhi-dong-tai-ding-shi-ren-wu/">
        </link>
        <updated>2022-01-28T01:39:11.000Z</updated>
        <content type="html"><![CDATA[<p>学习博客：在Spring Boot中优雅的实现定时任务 <a href="https://">https://zhuanlan.zhihu.com/p/79644891</a></p>
<h2 id="1启动类上增加enablescheduling">1.启动类上增加@EnableScheduling</h2>
<br/>
<h2 id="2数据库增加定时任务表">2.数据库增加定时任务表</h2>
<pre><code class="language-sql">-- auto-generated definition
create table m_scheduled
(
    cron_id         int auto_increment comment '主键id'
        primary key,
    cron_key        varchar(128)           not null comment '定时任务完整类名',
    cron_expression varchar(20)            not null comment 'cron表达式',
    task_explain    varchar(50) default '' not null comment '任务描述',
    status          tinyint     default 1  not null comment '状态,1:正常;2:停用',
    constraint cron_key
        unique (cron_key),
    constraint cron_key_unique_idx
        unique (cron_key)
)
    comment '定时任务表';

</code></pre>
<br/>
<h2 id="3定时任务config">3.定时任务config</h2>
<pre><code class="language-java">@Configuration
public class ScheduledConfig implements SchedulingConfigurer {

    @Autowired
    private ApplicationContext context;
    @Autowired
    private IScheduledService scheduledService;

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        for (Scheduled springScheduledCron : scheduledService.list()) {
            Class&lt;?&gt; clazz;
            Object task;
            try {
                clazz = Class.forName(springScheduledCron.getCronKey());
                task = context.getBean(clazz);
            } catch (ClassNotFoundException e) {
                throw new IllegalArgumentException(&quot;spring_scheduled_cron表数据&quot; + springScheduledCron.getCronKey() + &quot;有误&quot;, e);
            } catch (BeansException e) {
                throw new IllegalArgumentException(springScheduledCron.getCronKey() + &quot;未纳入到spring管理&quot;, e);
            }
            Assert.isAssignable(ScheduledOfTask.class, task.getClass(), &quot;定时任务类必须实现ScheduledOfTask接口&quot;);
            // 可以通过改变数据库数据进而实现动态改变执行周期
            taskRegistrar.addTriggerTask(((Runnable) task),
                    triggerContext -&gt; {
                        String cronExpression = scheduledService.findByCronKey(springScheduledCron.getCronKey()).getCronExpression();
                        return new CronTrigger(cronExpression).nextExecutionTime(triggerContext);
                    }
            );
        }
    }

    @Bean
    public Executor taskExecutor() {
        return Executors.newScheduledThreadPool(10);
    }
}

</code></pre>
<br/>
<h2 id="4定时任务实现">4.定时任务实现</h2>
<h3 id="41-定义接口">4.1 定义接口</h3>
<pre><code class="language-java">public interface ScheduledOfTask extends Runnable {
    /**
     * 定时任务方法
     */
    void execute();
    /**
     * 实现控制定时任务启用或禁用的功能
     */
    @Override
    default void run() {
        IScheduledService repository = SpringUtil.getBean(IScheduledService.class);
        Scheduled scheduledCron = repository.findByCronKey(this.getClass().getName());
        // 禁用则不处理
        if (StatusEnum.DISABLED.getCode().equals(scheduledCron.getStatus())) {
            return;
        }
        execute();
    }
}
</code></pre>
<br/>
<h3 id="42定时任务都需要实现此接口">4.2定时任务都需要实现此接口</h3>
<pre><code class="language-java">@Component
@Slf4j
public class DynamicPrintTask implements ScheduledOfTask {

    private int i;

    @Override
    public void execute() {
        log.info(&quot;thread id:{},DynamicPrintTask execute times:{}&quot;, Thread.currentThread().getId(), ++i);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring boot + Mybatis Plus 实现动态多数据源]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/spring-boot-mybatis-plus-shi-xian-dong-tai-duo-shu-ju-yuan/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/spring-boot-mybatis-plus-shi-xian-dong-tai-duo-shu-ju-yuan/">
        </link>
        <updated>2022-01-28T01:37:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="maven依赖">Maven依赖</h2>
<pre><code class="language-xml">&lt;!-- mybatis-plus --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;${mybatis-plus.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- 动态数据源 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;${dynamic-datasource-spring-boot-starter.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<br/>
<h2 id="springyml配置">Spring.yml配置</h2>
<pre><code class="language-yaml">spring:
  datasource:
    dynamic:
      primary: master #设置默认的数据源或者数据源组,默认值即为master
      strict: false #严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源
      datasource:
        master:
          url: jdbc:mysql://xx.xx.xx.xx:3306/dynamic
          username: root
          password: 123456
          driver-class-name: com.mysql.jdbc.Driver # 3.2.0开始支持SPI可省略此配置
</code></pre>
<br/>
<h2 id="读取默认数据源">读取默认数据源</h2>
<pre><code class="language-java">package com.mobai.osj.config.datasource;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author mxc
 * @date 2021-09-30
 * @description 默认数据源配置
 */
@Configuration
public class DataSourceConfig {

    @Value(&quot;${spring.datasource.dynamic.datasource.master.driver-class-name}&quot;)
    private String driverClassName;
    @Value(&quot;${spring.datasource.dynamic.datasource.master.url}&quot;)
    private String url;
    @Value(&quot;${spring.datasource.dynamic.datasource.master.username}&quot;)
    private String username;
    @Value(&quot;${spring.datasource.dynamic.datasource.master.password}&quot;)
    private String password;

    @Bean
    public MysqlDynamicDataSourceProvider mysqlDynamicDataSourceProvider(){
        return new MysqlDynamicDataSourceProvider(driverClassName,url,username,password);
    }
}

</code></pre>
<br/>
<h3 id="程序启动后读取数据库中所有数据源">程序启动后，读取数据库中所有数据源</h3>
<pre><code class="language-java">package com.mobai.osj.config.datasource;

import com.baomidou.dynamic.datasource.provider.AbstractJdbcDataSourceProvider;
import com.baomidou.dynamic.datasource.spring.boot.autoconfigure.DataSourceProperty;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.Map;

/**
 * @author mxc
 * @date 2021-09-30
 * @description 动态数据源配置
 */
public class MysqlDynamicDataSourceProvider extends AbstractJdbcDataSourceProvider {

    public MysqlDynamicDataSourceProvider(String driverClassName, String url, String username, String password) {
        super(driverClassName, url, username, password);
    }

    @Override
    protected Map&lt;String, DataSourceProperty&gt; executeStmt(Statement statement) throws SQLException {
        ResultSet rs = statement.executeQuery(&quot;select * from sys_data_source&quot;);
        Map&lt;String, DataSourceProperty&gt; map = new HashMap&lt;&gt;(4);

        // 从数据库中获取信息
        while(rs.next()){
            String code = rs.getString(&quot;code&quot;);
            String url = rs.getString(&quot;db_url&quot;);
            String username = rs.getString(&quot;db_username&quot;);
            String password = rs.getString(&quot;db_password&quot;);
            String key = rs.getString(&quot;db_name&quot;);
            String driverClassName = rs.getString(&quot;db_driver&quot;);

            DataSourceProperty dataSourceProperty = new DataSourceProperty();
            dataSourceProperty.setPoolName(code);
            dataSourceProperty.setDriverClassName(driverClassName);
            dataSourceProperty.setUrl(url);
            dataSourceProperty.setUsername(username);
            dataSourceProperty.setPassword(password);

            map.put(key,dataSourceProperty);
        }
        return map;
    }
}

</code></pre>
<br/>
<h3 id="ds数据源名称指定数据源处理业务">@DS(数据源名称)指定数据源，处理业务</h3>
<pre><code class="language-java">package com.mobai.osj.system.service.impl;

import com.baomidou.dynamic.datasource.annotation.DS;
import com.mobai.osj.system.service.BusinessService;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * @author mxc
 * @date 2022-01-06
 * @description 跨服务实现层
 */
@AllArgsConstructor
@Service
public class BusinessServiceImpl implements BusinessService {

    final private DataSource datasource;

    @DS(&quot;OSJ_PRO&quot;)
    @Override
    public ResultSet selectForJapanBigPromotion(String sql) throws SQLException {
        Connection connection = datasource.getConnection();
        Statement statement = connection.prepareStatement(sql);
        return statement.executeQuery(sql);
    }
}

</code></pre>
<br/>
<h3 id="数据库数据源配置">数据库数据源配置</h3>
<pre><code class="language-sql">CREATE TABLE `sys_data_source` (
  `id` varchar(36) NOT NULL,
  `code` varchar(100) DEFAULT NULL COMMENT '数据源编码',
  `name` varchar(100) DEFAULT NULL COMMENT '数据源名称',
  `remark` varchar(200) DEFAULT NULL COMMENT '备注',
  `db_type` varchar(10) DEFAULT NULL COMMENT '数据库类型',
  `db_driver` varchar(100) DEFAULT NULL COMMENT '驱动类',
  `db_url` varchar(500) DEFAULT NULL COMMENT '数据源地址',
  `db_name` varchar(100) DEFAULT NULL COMMENT '数据库名称',
  `db_username` varchar(100) DEFAULT NULL COMMENT '用户名',
  `db_password` varchar(100) DEFAULT NULL COMMENT '密码',
  `create_by` varchar(50) DEFAULT NULL COMMENT '创建人',
  `create_time` datetime DEFAULT NULL COMMENT '创建日期',
  `update_by` varchar(50) DEFAULT NULL COMMENT '更新人',
  `update_time` datetime DEFAULT NULL COMMENT '更新日期',
  `sys_org_code` varchar(64) DEFAULT NULL COMMENT '所属部门',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE KEY `sys_data_source_code_uni` (`code`) USING BTREE,
  UNIQUE KEY `uk_sdc_rule_code` (`code`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并发编程（一）：线程池 【非原创】]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/ce-shi-bai-du-kong-jian-shi-fou-ke-yong/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/ce-shi-bai-du-kong-jian-shi-fou-ke-yong/">
        </link>
        <updated>2022-01-20T07:37:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1线程池的好处">1.线程池的好处</h2>
<p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>
<ul>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的销毁</li>
<li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<br/>
<h2 id="2executor">2.Executor</h2>
<h3 id="21简介">2.1简介</h3>
<p>Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。有助于避免this逃逸。</p>
<blockquote>
<p>this逃逸：是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误</p>
</blockquote>
<h3 id="22executor框架结构主要由三大部分组成">2.2Executor框架结构（主要由三大部分组成）</h3>
<p>1**.任务（Runnable/Callable)**</p>
<p><strong>2.任务的执行（Executor)</strong></p>
<pre><code>这里重点类是ThreadPoolExecutor 和 ScheduledThreadPoolExecutor
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333083829.png" alt="" loading="lazy"></figure>
<p><strong>3.异步计算结果（Future)</strong></p>
<p>Future 接口以及 Future 接口的实现类 FutureTask 类都可以代表异步计算的结果。</p>
<p>当我们把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。（调用 submit() 方法时会返回一个 FutureTask 对象）</p>
<h3 id="23executor框架的使用示意图">2.3Executor框架的使用示意图</h3>
<figure data-type="image" tabindex="2"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333102632.png" alt="" loading="lazy"></figure>
<ol>
<li>主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。</li>
<li>把创建完成的实现 Runnable/Callable接口的 对象直接交给 ExecutorService 执行: ExecutorService.execute（Runnable command））或者也可以把 Runnable 对象或Callable 对象提交给 ExecutorService 执行（ExecutorService.submit（Runnable task）或 ExecutorService.submit（Callable <T> task））。</li>
<li>如果执行 ExecutorService.submit（…），ExecutorService 将返回一个实现Future接口的对象（我们刚刚也提到过了执行 execute()方法和 submit()方法的区别，submit()会返回一个 FutureTask 对象）。由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。</li>
<li>最后，主线程可以执行 FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</li>
</ol>
<p><strong>注：future:集Runnable、Callable、Future于一身,future.get()会造成当前线程的阻塞，在ExecutorService框架中，由于使用线程池，所以Runnable与Callable实例都当做任务看待，而不会当做“线程”看待。调用时如果任务还未执行完就会阻塞直到任务完成；当然我们也可以调用get的另一重载版本get(long timeout, TimeUnit unit)，当阻塞时会等待指定的时间，如果时间到而任务还未完成，那么就会抛出TimeoutException</strong></p>
<br/>
<h2 id="3重要threadpoolexecutor">3.【重要】ThreadPoolExecutor</h2>
<h3 id="31七大核心参数">3.1七大核心参数</h3>
<p>源码截图</p>
<figure data-type="image" tabindex="3"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333116958.png" alt="" loading="lazy"></figure>
<ol>
<li>corePoolSize：线程池中最小运行的数量</li>
<li>workQueue：&gt; corePoolSize会放入队列中</li>
<li>maximumPoolSize ：队列满了，可以同时运行的线程数量变为最大线程数</li>
<li>handler ：饱和策略/拒绝策略
<ol>
<li>
<p>ThreadPoolExecutor.AbortPolicy（默认）：抛出 RejectedExecutionException来拒绝新任务的处理。<br>
【银行满了，还有人进来，不处理这个人，抛出异常】</p>
</li>
<li>
<p>ThreadPoolExecutor.CallerRunsPolicy ：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。<br>
【哪来的去哪里】只要撑不死，就往死里吃，说是提供了可伸缩的队列，没看着<br>
<img src="https://2321079146.github.io/mobai.github.io//post-images/1643333166082.png" alt="" loading="lazy"></p>
</li>
<li>
<p>ThreadPoolExecutor.DiscardPolicy ：不处理新任务，直接丢弃掉。<br>
【不会抛出异常】</p>
</li>
<li>
<p>ThreadPoolExecutor.DiscardOldestPolicy ：此策略将丢弃最早的未处理的任务请求。</p>
<pre><code>  【队列满了，尝试和最早的竞争，也不会抛出异常】
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="32注意">3.2注意</h3>
<blockquote>
<p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>
</blockquote>
<p>因为通过FixedThreadPool 、SingleThreadExecutor 、CachedThreadPool 、ScheduledThreadPool<br>
这样创建线程池，很容易导致oom<br>
<img src="https://2321079146.github.io/mobai.github.io//post-images/1643333200120.png" alt="" loading="lazy"></p>
<br/>
<br/>
<h2 id="4建议不同业务使用不同的线程池">4.建议不同业务使用不同的线程池</h2>
<p>真实案例：若有父任务和子任务都使用一个线程池，那么当父任务耗尽了线程池的资源，而子任务无法争取到线程资源，但是父任务需要等到子任务完成后才能结束让出线程资源，则会造成死锁。</p>
<br/>
<h2 id="5线程池命名">5.线程池命名</h2>
<p>若是默认的线程池名称，没有任何的业务意义，若出现了业务问题，则不好定位问题</p>
<ol>
<li>
<p>.利用 guava 的 ThreadFactoryBuilder</p>
<pre><code class="language-java">ThreadFactory threadFactory = new ThreadFactoryBuilder()
                        .setNameFormat(threadNamePrefix + &quot;-%d&quot;)
                        .setDaemon(true).build();
ExecutorService threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)
</code></pre>
</li>
<li>
<p>自定义</p>
<pre><code class="language-java">import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;
/**
 * 线程工厂，它设置线程名称，有利于我们定位问题。
 */
public final class NamingThreadFactory implements ThreadFactory {

    private final AtomicInteger threadNum = new AtomicInteger();
    private final ThreadFactory delegate;
    private final String name;

    /**
     * 创建一个带名字的线程池生产工厂
     */
    public NamingThreadFactory(ThreadFactory delegate, String name) {
        this.delegate = delegate;
        this.name = name; // TODO consider uniquifying this
    }

    @Override 
    public Thread newThread(Runnable r) {
        Thread t = delegate.newThread(r);
        t.setName(name + &quot; [#&quot; + threadNum.incrementAndGet() + &quot;]&quot;);
        return t;
    }

}

</code></pre>
</li>
</ol>
<br/>
<h2 id="6正确配置线程池参数">6.正确配置线程池参数</h2>
<h3 id="61线程池执行示意图">6.1线程池执行示意图</h3>
<figure data-type="image" tabindex="4"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333248329.png" alt="" loading="lazy"></figure>
<h3 id="62线程池参数动态配置">6.2线程池参数动态配置</h3>
<p><strong>6.2.1 业务场景</strong></p>
<p>因为线程的参数设定需要对业务和线程的经验作为支撑，所以很可能出现参数过大或者过小的情况，导致业务异常，美团的解决方案是动态改变线程池设定的参数。</p>
<p><strong>6.2.2 问题</strong></p>
<ol>
<li>如何才能动态设定线程池的参数呢？</li>
<li>若进行线程池的替换，而原本的线程池中已经存在了任务，那么怎么才能做到无缝丝滑切换呢？</li>
</ol>
<p><strong>6.2.3 之前的解决方案</strong></p>
<p>先判断是CPU密集型还是IO密集型</p>
<ol>
<li>CPU密集型 = 核心数 + 1<br>
这个1类似于一个备份线程</li>
<li>IO密集型【计算公式】<br>
<img src="https://2321079146.github.io/mobai.github.io//post-images/1643333261128.png" alt="" loading="lazy"></li>
</ol>
<br/>
<hr>
<p>接下来是现有的方案：动态参数配置</p>
<p><strong>6.2.4 动态更新的工作原理</strong></p>
<pre><code>*查看源码就会发现，corePoolSize和maximumPoolSize都是可以动态调整的*

在线程运行时，重新赋值corePoolSize之后的流程：
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333278513.png" alt="" loading="lazy"></figure>
<br/>
<p><strong>6.2.5 动态设置的注意点</strong></p>
<pre><code>问题1：调整后可能会出现调整无效的情况，若工作线程数大于最大线程数
</code></pre>
<ol>
<li>
<p>创建新的工作线程 worker，然后工作线程数进行加一操作。</p>
</li>
<li>
<p>运行创建的工作线程 worker，开始获取任务 task。</p>
</li>
<li>
<p>工作线程数量大于最大线程数，对工作线程数进行减一操作。返回 null，即没有获取到 task。</p>
</li>
<li>
<p>清理该任务，流程结束。</p>
<p><em>这样一加一减，所以真正在执行任务的工作线程数的数量一直没有发生变化，也就是最大线程数。设置核心线程数的时候，同时设置最大线			程数即可。其实可以把二者设置为相同的值：</em>、</p>
</li>
</ol>
<br/>
<pre><code>问题2：如果调整之后把活动线程数设置的值太大了，岂不是业务低峰期我们还需要人工把值调的小一点？

当 allowCoreThreadTimeOut 参数设置为 true 的时候，核心线程在空闲了 keepAliveTime 的时间后也会被回收的，相当于线程池自动给你动态修改了。
</code></pre>
<br/>
<pre><code>问题3：如何动态的修改队列长度

美团解决自定义队列**ResizableCapacityLinkedBlockIngQueue**，可以自定义长度
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333297882.png" alt="" loading="lazy"></figure>
<br/>
<p><strong>6.2.6  线程池创建问题</strong></p>
<pre><code>问题1：线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？
</code></pre>
<ol>
<li>**prestartAllCoreThreads **全部启动</li>
<li>**prestartCoreThread **仅启动一个</li>
</ol>
<br/>
<pre><code>问题2：核心线程数会被回收吗？需要什么设置？

可，调用**allowCoreThreadTimeOut**设置为 rue
</code></pre>
<br/>
<p><strong>6.2.7 代码示例</strong></p>
<pre><code class="language-java">package com.mobai.thread;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author mxc
 * @date 2022-01-27
 * @description 正常创建线程池示例
 */
public class ThreadPoolDemo {

    public static void main(String[] args) throws InterruptedException {
        long start = System.currentTimeMillis();
        dynamicModifyExector();
        System.out.println(&quot;一共使用时间&quot; + (System.currentTimeMillis() - start));
    }

    private static void dynamicModifyExector() throws InterruptedException {

        ThreadPoolExecutor executor = buildThreadPoolExecutor();
        for (int i = 0; i &lt; 15; i++) {
            executor.submit(() -&gt; {
                threadPoolStatus(executor, &quot;创建任务&quot;);
                try{
                    TimeUnit.SECONDS.sleep(10);
                }catch (Exception e){
                    e.printStackTrace();
                }
            });
        }

        threadPoolStatus(executor, &quot;改变之前&quot;);
        executor.setCorePoolSize(10);
        executor.setMaximumPoolSize(10);
        // 启动所有的核心线程数
        executor.prestartCoreThread();
        threadPoolStatus(executor, &quot;改变之后&quot;);
        Thread.currentThread().join();
    }

    private static ThreadPoolExecutor buildThreadPoolExecutor() {
        return new ThreadPoolExecutor(2
                , 5
                , 60
                , TimeUnit.SECONDS
                , new LinkedBlockingQueue&lt;&gt;(10)
                , new NameThreadFactory(&quot;自定义线程池&quot;));
    }


    /**
     * 打印线程池状态
     * @param executor 线程池
     * @param name 名称
     */
    public static void threadPoolStatus(ThreadPoolExecutor executor, String name){
        BlockingQueue&lt;Runnable&gt; queue = executor.getQueue();

        System.out.println(Thread.currentThread().getName() + &quot;-&quot; + name + &quot;-&quot; +
                &quot; 核心线程数：&quot; + executor.getCorePoolSize() +
                &quot; 活动线程数：&quot; + executor.getActiveCount() +
                &quot; 最大线程数：&quot; + executor.getMaximumPoolSize() +
                &quot; 线程池活跃度：&quot; + divide(executor.getActiveCount(), executor.getMaximumPoolSize()) +
                &quot; 任务完成数：&quot; + executor.getCompletedTaskCount() +
                &quot; 队列大小：&quot; + (queue.size() + queue.remainingCapacity()) +
                &quot; 当前排队线程数：&quot; + queue.size() +
                &quot; 队列剩余大小：&quot; + queue.remainingCapacity() +
                &quot; 队列使用度：&quot; + (divide(queue.size(), queue.size() + queue.remainingCapacity()))
        );
    }

    /**
     * 保留两位小数
     * @param num1 参数1
     * @param num2 参数2
     * @return 计算结果
     */
    private static String divide(int num1, int num2){
        return String.format(&quot;%1.2f%%&quot;, Double.parseDouble(num1 + &quot;&quot;) / Double.parseDouble(num2 + &quot;&quot;) * 100);
    }
}

</code></pre>
]]></content>
    </entry>
</feed>