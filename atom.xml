<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2321079146.github.io/mobai.github.io/</id>
    <title>墨白</title>
    <updated>2022-01-28T05:59:20.683Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2321079146.github.io/mobai.github.io/"/>
    <link rel="self" href="https://2321079146.github.io/mobai.github.io/atom.xml"/>
    <subtitle>芜湖，起飞</subtitle>
    <logo>https://2321079146.github.io/mobai.github.io/images/avatar.png</logo>
    <icon>https://2321079146.github.io/mobai.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 墨白</rights>
    <entry>
        <title type="html"><![CDATA[barcode4j生成条形码，zxing生成二维码，zxing识别，itextpdf增加至pdf中]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/barcode4j-sheng-cheng-tiao-xing-ma-zxing-sheng-cheng-er-wei-ma-zxing-shi-bie-itextpdf-zeng-jia-zhi-pdf-zhong/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/barcode4j-sheng-cheng-tiao-xing-ma-zxing-sheng-cheng-er-wei-ma-zxing-shi-bie-itextpdf-zeng-jia-zhi-pdf-zhong/">
        </link>
        <updated>2022-01-28T01:44:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-java">package osj.web.util;

import com.google.zxing.*;
import com.google.zxing.client.j2se.BufferedImageLuminanceSource;
import com.google.zxing.client.j2se.MatrixToImageWriter;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.common.HybridBinarizer;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.pdf.ColumnText;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfWriter;
import org.apache.commons.lang3.StringUtils;
import org.krysalis.barcode4j.impl.code128.Code128Bean;
import org.krysalis.barcode4j.impl.code128.Code128Constants;
import org.krysalis.barcode4j.output.bitmap.BitmapCanvasProvider;
import org.krysalis.barcode4j.tools.UnitConv;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import osj.web.exception.BusinessException;

import javax.imageio.ImageIO;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.file.Path;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.zip.ZipOutputStream;

/**
 * @Author: mxc
 * @Date: 2021-08-09
 * @Description: 二维码工具类
 */
public class BarcodeUtil {

    private static final Logger logger = LoggerFactory.getLogger(BarcodeUtil.class);

    /**
     * itextpdf 创建Pdf
     * @param sku sku信息
     * @param skuFilePath sku保存路径
     */
    public static String createBarcodePdf(String sku, String skuFilePath){
        if (StringUtils.isBlank(sku)) {
            return null;
        }
        String newFilePath = skuFilePath + sku + &quot;.pdf&quot;;
        try {
            File mkdir = new File(skuFilePath);
            if (!mkdir.exists()) {
                if (!mkdir.mkdirs()) {
                    throw new BusinessException(&quot;目录创建失败&quot;);
                }
            }
            FileOutputStream out = new FileOutputStream(newFilePath);
            // Step 1—Create a Document.
            com.itextpdf.text.Rectangle pageSize = new com.itextpdf.text.Rectangle(328, 125);
            Document document = new Document(pageSize);
            // Step 2—Get a PdfWriter instance.
            PdfWriter pdfWriter = PdfWriter.getInstance(document, out);
            // Step 3—Open the Document.
            document.open();
            // PdfContentByte cb = new PdfContentByte(pdfWriter); document直接添加元素使用这个
            PdfContentByte cb = pdfWriter.getDirectContent();

            // 生成code128A条形码
            String code128Image = createSkuCode128A(sku, skuFilePath);
            // 生成二维码
            String qrCode = createSkuQrCode(sku, skuFilePath);

            if (StringUtils.isEmpty(code128Image) || StringUtils.isEmpty(qrCode)) {
                throw new BusinessException(&quot;二维码或者条形码图片生成失败&quot;);
            }

            // 将生成的图片添加到pdf中
            imageAddToPdf(cb, document, code128Image, qrCode, sku);

            // Step 4—Close the Document.
            document.close();
            out.close();

            // 删除图片临时文件
            File codeFile = new File(code128Image);
            if (codeFile.exists()) {
                if (!codeFile.delete()) {
                    throw new BusinessException(&quot;条形码图片删除失败&quot;);
                }
            }

            File qrCodeFile = new File(qrCode);
            if (qrCodeFile.exists()) {
                if (!qrCodeFile.delete()) {
                    throw new BusinessException(&quot;二维码图片删除失败&quot;);
                }
            }
        }catch (Exception e) {
            logger.error(&quot;创建skuPdf失败&quot;,e);
        }
        return newFilePath;
    }

    /**
     * 将图片添加到pdf中
     * @param document document
     * @param code128Image 条形码图片路径
     * @param qrCode 二维码图片路径
     * @param sku sku
     * @throws DocumentException document异常
     * @throws IOException io异常
     */
    private static void imageAddToPdf(PdfContentByte cb, Document document,String code128Image, String qrCode, String sku) throws Exception {

        com.itextpdf.text.Image code128ImageFile = com.itextpdf.text.Image.getInstance(code128Image);

        int qrCodeWith = 90;

        int codeWidth = 200;

        int codeHeight = 30;

        String str = &quot;PJ&quot;;
        // 配件sku增加标识
        if (sku.startsWith(str)) {
            // 文本框位置
            com.itextpdf.text.Rectangle rect = new com.itextpdf.text.Rectangle(165, 120, 85, 60);
            ColumnText cts = new ColumnText(cb);
            cts.addText(new Phrase(&quot;** PJ **&quot;));
            cts.setSimpleColumn(rect);
            cts.go();
        }
        code128ImageFile.setWidthPercentage(100);
        code128ImageFile.setAbsolutePosition(0, 40);
        code128ImageFile.scaleToFit(220,40 + codeHeight);
        String code128Str = imageDecode(code128Image);
        if (!sku.equals(code128Str)) {
            logger.error(&quot;sku:&quot; + sku + &quot;|&quot; + &quot;条形码:&quot; + code128Str);
            throw new BusinessException(&quot;条形码识别信息与sku不匹配&quot;);
        }

        // 文本框位置
        com.itextpdf.text.Rectangle rect = new com.itextpdf.text.Rectangle(65, 35, 180, 15);
        ColumnText cts = new ColumnText(cb);
        cts.addText(new Phrase(sku));
        cts.setSimpleColumn(rect);
        cts.go();

        cb.addImage(code128ImageFile);

        com.itextpdf.text.Image qrCodeImageFile = com.itextpdf.text.Image.getInstance(qrCode);
        qrCodeImageFile.setAbsolutePosition(200, 0);
        code128ImageFile.scaleToFit(230 + qrCodeWith,qrCodeWith + 20);
        String qrCodeStr = imageDecode(code128Image);
        if (!sku.equals(qrCodeStr)) {
            logger.error(&quot;sku:&quot; + sku + &quot;|&quot; + &quot;二维码:&quot; + code128Str);
            throw new BusinessException(&quot;二维码识别信息与sku不匹配&quot;);
        }
        cb.addImage(qrCodeImageFile);
    }

    /**
     * 使用zxing生成二维码
     * barcode4j现无二维码编辑器
     * 官方文档解释：Barcode4J does not currently contain an actual QR Code encoder. The QR Code support is currently just an adapter to ZXing's QR encoder.
     *            This means that ZXing Core 1.7 (or later) has to be in the classpath for this to work.
     *            Barcode4J may get its own QR Code encoder sometime in the future.
     * @param sku sku
     * @param skuPath 基础路径
     * @return 新文件路径
     * @throws FileNotFoundException 文件找不到异常
     */
    private static String createSkuQrCode(String sku, String skuPath) throws FileNotFoundException, WriterException {
        String newFilePath = skuPath + sku + &quot;_2.png&quot;;

        try {
            BitMatrix bitMatrix = new MultiFormatWriter().encode(sku,
                    BarcodeFormat.QR_CODE, 120, 120, null);

            Path path = new File(newFilePath).toPath();
            MatrixToImageWriter.writeToPath(bitMatrix, &quot;png&quot;,path);

        } catch (Exception e) {
            e.printStackTrace();
        }
        return newFilePath;
    }

    /**
     *
     * barcode4j生成code128A条形码
     * @param sku sku
     * @param skuPath 基础路径
     * @return 新路径
     * @throws FileNotFoundException 文件未找到
     */
    private static String createSkuCode128A(String sku, String skuPath) throws FileNotFoundException {
        String newFilePath = skuPath + sku + &quot;_1.png&quot;;
        File file = new File(newFilePath);
        OutputStream out = new FileOutputStream(file);
        if (StringUtils.isEmpty(sku)) {
            return null;
        }

        Code128Bean bean = new Code128Bean();
        // 精细度
        final int dpi = 400;
        // module宽度
        final double moduleWidth = UnitConv.in2mm(1.0f / dpi);

        // 配置图片相关属性
        bean.setBarHeight(4);
        // 只能使用code128A生成
        bean.setCodeset(Code128Constants.CODESET_A);
        bean.setModuleWidth(moduleWidth);
        // 左右是否留空
        bean.doQuietZone(true);
        // 底部字体的大小
        bean.setFontSize(0);
        String format = &quot;image/png&quot;;

        try {
            BitmapCanvasProvider canvas = new BitmapCanvasProvider(out, format, dpi,
                    BufferedImage.TYPE_BYTE_BINARY, false, 0);
            // 生成条形码
            bean.generateBarcode(canvas, sku);
            // 完成绘制
            canvas.finish();
            out.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return newFilePath;
    }

    /**
     * zxing识别图形中包含信息
     *
     * @throws IOException io异常
     */
    public static String imageDecode(String filePath) throws Exception {
        BufferedImage image;
        Result result = null;
        try {
            image = ImageIO.read(new File(filePath));
            if (image == null) {
                throw new BusinessException(&quot;图片不存在或者创建失败&quot;);
            }
            LuminanceSource source = new BufferedImageLuminanceSource(image);
            BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));

            result = new MultiFormatReader().decode(bitmap, null);
            return result.getText();
        } catch (Exception e) {
            e.printStackTrace();
        }
        if (result == null) {
            throw new BusinessException(&quot;图片识别异常&quot;);
        }
        return null;
    }


    /**
     * 校验sku
     *
     * @param skuName sku名称
     * @return 是否正确
     */
    public static boolean isValid(String skuName) {
        String regex = &quot;^[a-zA-Z]{2}[0-9]{6}[a-zA-Z]{3}$&quot;;
        skuName = skuName.toUpperCase().trim();
        if (StringUtils.isBlank(skuName) || !skuName.matches(regex)) {
            System.out.println(&quot;请输入正确的SKU&quot;);
            return false;
        }

        return true;
    }

    /**
     * 单个文件下载
     *
     * @param fileName 文件名
     * @param type     二维码尺寸类型
     * @return 校验信息
     */
    public static String doDownLoad(HttpServletRequest request, HttpServletResponse response, String fileName, int type) {
        String requestUrl = request.getSession().getServletContext().getRealPath(&quot;/&quot;);
        String filePath = requestUrl + &quot;barcode/&quot; + fileName + &quot;.pdf&quot;;
        File file = new File(filePath);

        if (!isValid(fileName)) {
            return &quot;SKU格式不规范&quot;;
        }

        // 文件存在则直接获取文件,若不存在则需要下载
        if (!file.exists()) {
            createBarcodePdf(fileName, requestUrl + &quot;barcode/&quot;);
        }
        return null;
    }

    /**
     * 批量文件zip下载
     *
     * @param skuCodes 文件名
     * @param type     二维码尺寸类型
     * @return 校验信息
     */
    public static String batchDownLoad(HttpServletRequest request, HttpServletResponse response, List&lt;String&gt; skuCodes, int type) {
        String requestUrl = request.getSession().getServletContext().getRealPath(&quot;/&quot;);

        // 获取校验通过的文件【前端已校验格式】
        List&lt;File&gt; files = new ArrayList&lt;&gt;();
        for (String skuCode : skuCodes) {
            String filePath = requestUrl + &quot;barcode/&quot; + skuCode + &quot;.pdf&quot;;
            File file = new File(filePath);
            // 文件存在则直接获取文件,若不存在则需要下载
            if (!file.exists()) {
                createBarcodePdf(skuCode,  requestUrl + &quot;barcode/&quot;);
                file = new File(filePath);
            }
            files.add(file);
        }

        Date currentDate = new Date();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;);
        String currentTime = sdf.format(currentDate);
        // 遍历文件存入到zip文件中
        String zip = currentTime + &quot;.zip&quot;;
        File fileZip = new File(requestUrl + &quot;download/&quot; + zip);
        // 文件输出流
        FileOutputStream outStream = null;
        ZipOutputStream toClient = null;
        try {
            outStream = new FileOutputStream(fileZip);
            // 压缩流
            toClient = new ZipOutputStream(outStream);
            // 存入到本地服务器中
            FileAddToZipUtil.zipFile(files, toClient);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                if (toClient != null) {
                    toClient.flush();
                    toClient.close();
                }
                if (outStream != null) {
                    outStream.flush();
                    outStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return zip;
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spire创建code128A和条形码]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/spire-chuang-jian-code128a-he-tiao-xing-ma/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/spire-chuang-jian-code128a-he-tiao-xing-ma/">
        </link>
        <updated>2022-01-28T01:42:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="代码展示">代码展示</h2>
<pre><code class="language-java">    /**
     * 创建二维码
     *
     * @param sku         sku名称
     * @param skuFilePath 文件保存地址
     * @param type        二维码类型
     * @return 文件保存路径
     */
    public static String createPdf(String sku, String skuFilePath, int type) {
        if (StringUtils.isBlank(sku)) {
            return null;
        }

        int pdfWidth, pdfHeight;
        float qrWidth;
        double barcodeWidth, barcodeHeight;
        int fontsize;
        float leftMargin, topMargin;

        if (type == OsjConstant.BARCODE_COMMON) {// 普通版本
            pdfWidth = 308;
            pdfHeight = 105;
            qrWidth = 93;
            barcodeWidth = 190;
            barcodeHeight = 65;
            fontsize = 26;
            leftMargin = 6;
            topMargin = 6;
        } else if (type == OsjConstant.BARCODE_BIG_WIDTH) {// 大边距普通版本
            // pdf页面宽度
            pdfWidth = 328;
            // PDF页面高度
            pdfHeight = 125;
            // 二维码尺寸
            qrWidth = 90;
            // 条形码宽度
            barcodeWidth = 180;
            // 条形码高度
            barcodeHeight = 65;
            // 条形码下面的字的尺寸
            fontsize = 15;
            // 条形码离左侧的距离
            leftMargin = 16;
            // 条形码离上面的距离
            topMargin = 16;
        } else {// 条码宽版本
            pdfWidth = 328;
            pdfHeight = 105;
            qrWidth = 93;
            barcodeWidth = 210;
            barcodeHeight = 62;
            fontsize = 29;
            leftMargin = 6;
            topMargin = 6;
        }

        //创建PdfDocument对象
        PdfDocument doc = new PdfDocument();
        Dimension2D pdfSize = new Dimension(pdfWidth, pdfHeight);
        PdfMargins margins = new PdfMargins(leftMargin, topMargin);
        //添加一页
        PdfPageBase page = doc.getPages().add(pdfSize, margins);
        page.setBackgroudOpacity(0);
        //初始化y变量
        double y = 0;

        // 配件sku需增加字符串显示
        final String partsStr = &quot;PJ&quot;;
        if (sku.startsWith(partsStr)) {
            y = 35;
            barcodeHeight = 30;
            Point2D.Float pointPJ = new Point2D.Float();
            pointPJ.setLocation(50,1);
            page.getCanvas().drawString(&quot;** PARTS **&quot;, new PdfTrueTypeFont(new Font(&quot;Arial&quot;, Font.BOLD, fontsize), true),
                    new PdfSolidBrush(new PdfRGBColor(Color.black)), pointPJ);
        }

        Point2D.Float point = new Point2D.Float();
        point.setLocation(0, y);

        // 绘制Code128A条码到PDF
        BarcodeSettings settingsCode = new BarcodeSettings();
        // 设置条形码类型
        settingsCode.setType(BarCodeType.Code_128);
        // code128a
        settingsCode.setCode128SetMode(Code128SetMode.Only_A);
        // 设置条形码数据
        settingsCode.setData(sku);
        // 不显示文本
        settingsCode.setShowText(false);
        //在底部显示数据
        settingsCode.setShowTextOnBottom(true);
        //设置边框为不可见
        settingsCode.hasBorder(false);
        BarCodeGenerator generator = new BarCodeGenerator(settingsCode);

        Rectangle2D rect = new Rectangle();
        rect.setRect(point.x, y, barcodeWidth, barcodeHeight);
        //draw
        PdfImage pdfImage1 = PdfImage.fromImage(generator.generateImage());
        page.getCanvas().drawImage(pdfImage1, rect);

        y = y + barcodeHeight + 5;

        //-------创建字体---
        //location
        Point2D.Float pointW = new Point2D.Float();
        pointW.setLocation(45, y);
        //设置字体
        PdfTrueTypeFont font1 = new PdfTrueTypeFont(new Font(&quot;Arial&quot;, Font.BOLD, fontsize), true);
        for (int i = 1; i &lt; 10; i++) {
            Dimension2D tSize = font1.measureString(sku);
            System.out.println(tSize.getWidth());
            if (tSize.getWidth() &gt; (barcodeWidth - 1)) {
                fontsize = fontsize - 1;
                font1 = new PdfTrueTypeFont(new Font(&quot;Aria&quot;, Font.BOLD, fontsize), true);
            } else {
                break;
            }
        }
        //draw
        PdfSolidBrush brush = new PdfSolidBrush(new PdfRGBColor(Color.black));
        page.getCanvas().drawString(sku, font1, brush, pointW);

        //创建BarcodeSettings实例----------------------------------------------
        BarcodeSettings settings = new BarcodeSettings();
        //设置条码类型为QR二维码
        settings.setType(BarCodeType.QR_Code);
        //设置二维码数据
        settings.setData(sku);
        //设置二维码显示数据
        settings.setData2D(null);
        //设置数据类型
        settings.setQRCodeDataMode(QRCodeDataMode.Alpha_Number);
        //设置二维码纠错级别
        settings.setQRCodeECL(QRCodeECL.H);
        settings.setShowText(false);
        settings.setTopMargin(0);
        settings.setLeftMargin(0);
        settings.setRightMargin(0);
        settings.setBottomMargin(0);

        //创建BarCodeGenerator实例
        BarCodeGenerator barCodeGenerator = new BarCodeGenerator(settings);
        //根据settings生成图像数据，保存至BufferedImage实例
        BufferedImage bufferedImage = barCodeGenerator.generateImage();
        //绘制二维码图片到PDF页面指定位置
        PdfImage pdfImage = PdfImage.fromImage(bufferedImage);
        Rectangle2D rect2 = new Rectangle();
        rect2.setRect(barcodeWidth * 1.06, 0, qrWidth, qrWidth);
        page.getCanvas().drawImage(pdfImage, rect2);

        //check
        //--------------
        try {
            String[] dataArr = BarcodeScanner.scan(page.extractImages()[0], BarCodeType.Code_128);
            logger.info(Arrays.toString(dataArr) + &quot;  | &quot; + sku);
            if (dataArr.length == 0) {
                throw new OsjException(&quot;无法读取条码&quot;);
            }
            String nullStr = &quot;null&quot;;
            if (dataArr[0] == null || nullStr.equals(dataArr[0]) || !sku.equals(dataArr[0])) {
                throw new OsjException(&quot;无法读取条码&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        //----------------


        //保存PDF文档
        doc.saveToFile(skuFilePath);
        return skuFilePath;
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Boot 配置动态定时任务]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/spring-boot-pei-zhi-dong-tai-ding-shi-ren-wu/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/spring-boot-pei-zhi-dong-tai-ding-shi-ren-wu/">
        </link>
        <updated>2022-01-28T01:39:11.000Z</updated>
        <content type="html"><![CDATA[<p>学习博客：在Spring Boot中优雅的实现定时任务 <a href="https://">https://zhuanlan.zhihu.com/p/79644891</a></p>
<h2 id="1启动类上增加enablescheduling">1.启动类上增加@EnableScheduling</h2>
<br/>
<h2 id="2数据库增加定时任务表">2.数据库增加定时任务表</h2>
<pre><code class="language-sql">-- auto-generated definition
create table m_scheduled
(
    cron_id         int auto_increment comment '主键id'
        primary key,
    cron_key        varchar(128)           not null comment '定时任务完整类名',
    cron_expression varchar(20)            not null comment 'cron表达式',
    task_explain    varchar(50) default '' not null comment '任务描述',
    status          tinyint     default 1  not null comment '状态,1:正常;2:停用',
    constraint cron_key
        unique (cron_key),
    constraint cron_key_unique_idx
        unique (cron_key)
)
    comment '定时任务表';

</code></pre>
<br/>
<h2 id="3定时任务config">3.定时任务config</h2>
<pre><code class="language-java">@Configuration
public class ScheduledConfig implements SchedulingConfigurer {

    @Autowired
    private ApplicationContext context;
    @Autowired
    private IScheduledService scheduledService;

    @Override
    public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
        for (Scheduled springScheduledCron : scheduledService.list()) {
            Class&lt;?&gt; clazz;
            Object task;
            try {
                clazz = Class.forName(springScheduledCron.getCronKey());
                task = context.getBean(clazz);
            } catch (ClassNotFoundException e) {
                throw new IllegalArgumentException(&quot;spring_scheduled_cron表数据&quot; + springScheduledCron.getCronKey() + &quot;有误&quot;, e);
            } catch (BeansException e) {
                throw new IllegalArgumentException(springScheduledCron.getCronKey() + &quot;未纳入到spring管理&quot;, e);
            }
            Assert.isAssignable(ScheduledOfTask.class, task.getClass(), &quot;定时任务类必须实现ScheduledOfTask接口&quot;);
            // 可以通过改变数据库数据进而实现动态改变执行周期
            taskRegistrar.addTriggerTask(((Runnable) task),
                    triggerContext -&gt; {
                        String cronExpression = scheduledService.findByCronKey(springScheduledCron.getCronKey()).getCronExpression();
                        return new CronTrigger(cronExpression).nextExecutionTime(triggerContext);
                    }
            );
        }
    }

    @Bean
    public Executor taskExecutor() {
        return Executors.newScheduledThreadPool(10);
    }
}

</code></pre>
<br/>
<h2 id="4定时任务实现">4.定时任务实现</h2>
<h3 id="41-定义接口">4.1 定义接口</h3>
<pre><code class="language-java">public interface ScheduledOfTask extends Runnable {
    /**
     * 定时任务方法
     */
    void execute();
    /**
     * 实现控制定时任务启用或禁用的功能
     */
    @Override
    default void run() {
        IScheduledService repository = SpringUtil.getBean(IScheduledService.class);
        Scheduled scheduledCron = repository.findByCronKey(this.getClass().getName());
        // 禁用则不处理
        if (StatusEnum.DISABLED.getCode().equals(scheduledCron.getStatus())) {
            return;
        }
        execute();
    }
}
</code></pre>
<br/>
<h3 id="42定时任务都需要实现此接口">4.2定时任务都需要实现此接口</h3>
<pre><code class="language-java">@Component
@Slf4j
public class DynamicPrintTask implements ScheduledOfTask {

    private int i;

    @Override
    public void execute() {
        log.info(&quot;thread id:{},DynamicPrintTask execute times:{}&quot;, Thread.currentThread().getId(), ++i);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[spring boot + Mybatis Plus 实现动态多数据源]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/spring-boot-mybatis-plus-shi-xian-dong-tai-duo-shu-ju-yuan/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/spring-boot-mybatis-plus-shi-xian-dong-tai-duo-shu-ju-yuan/">
        </link>
        <updated>2022-01-28T01:37:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="maven依赖">Maven依赖</h2>
<pre><code class="language-xml">&lt;!-- mybatis-plus --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;${mybatis-plus.version}&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- 动态数据源 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;${dynamic-datasource-spring-boot-starter.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<br/>
<h2 id="springyml配置">Spring.yml配置</h2>
<pre><code class="language-yaml">spring:
  datasource:
    dynamic:
      primary: master #设置默认的数据源或者数据源组,默认值即为master
      strict: false #严格匹配数据源,默认false. true未匹配到指定数据源时抛异常,false使用默认数据源
      datasource:
        master:
          url: jdbc:mysql://xx.xx.xx.xx:3306/dynamic
          username: root
          password: 123456
          driver-class-name: com.mysql.jdbc.Driver # 3.2.0开始支持SPI可省略此配置
</code></pre>
<br/>
<h2 id="读取默认数据源">读取默认数据源</h2>
<pre><code class="language-java">package com.mobai.osj.config.datasource;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author mxc
 * @date 2021-09-30
 * @description 默认数据源配置
 */
@Configuration
public class DataSourceConfig {

    @Value(&quot;${spring.datasource.dynamic.datasource.master.driver-class-name}&quot;)
    private String driverClassName;
    @Value(&quot;${spring.datasource.dynamic.datasource.master.url}&quot;)
    private String url;
    @Value(&quot;${spring.datasource.dynamic.datasource.master.username}&quot;)
    private String username;
    @Value(&quot;${spring.datasource.dynamic.datasource.master.password}&quot;)
    private String password;

    @Bean
    public MysqlDynamicDataSourceProvider mysqlDynamicDataSourceProvider(){
        return new MysqlDynamicDataSourceProvider(driverClassName,url,username,password);
    }
}

</code></pre>
<br/>
<h3 id="程序启动后读取数据库中所有数据源">程序启动后，读取数据库中所有数据源</h3>
<pre><code class="language-java">package com.mobai.osj.config.datasource;

import com.baomidou.dynamic.datasource.provider.AbstractJdbcDataSourceProvider;
import com.baomidou.dynamic.datasource.spring.boot.autoconfigure.DataSourceProperty;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.Map;

/**
 * @author mxc
 * @date 2021-09-30
 * @description 动态数据源配置
 */
public class MysqlDynamicDataSourceProvider extends AbstractJdbcDataSourceProvider {

    public MysqlDynamicDataSourceProvider(String driverClassName, String url, String username, String password) {
        super(driverClassName, url, username, password);
    }

    @Override
    protected Map&lt;String, DataSourceProperty&gt; executeStmt(Statement statement) throws SQLException {
        ResultSet rs = statement.executeQuery(&quot;select * from sys_data_source&quot;);
        Map&lt;String, DataSourceProperty&gt; map = new HashMap&lt;&gt;(4);

        // 从数据库中获取信息
        while(rs.next()){
            String code = rs.getString(&quot;code&quot;);
            String url = rs.getString(&quot;db_url&quot;);
            String username = rs.getString(&quot;db_username&quot;);
            String password = rs.getString(&quot;db_password&quot;);
            String key = rs.getString(&quot;db_name&quot;);
            String driverClassName = rs.getString(&quot;db_driver&quot;);

            DataSourceProperty dataSourceProperty = new DataSourceProperty();
            dataSourceProperty.setPoolName(code);
            dataSourceProperty.setDriverClassName(driverClassName);
            dataSourceProperty.setUrl(url);
            dataSourceProperty.setUsername(username);
            dataSourceProperty.setPassword(password);

            map.put(key,dataSourceProperty);
        }
        return map;
    }
}

</code></pre>
<br/>
<h3 id="ds数据源名称指定数据源处理业务">@DS(数据源名称)指定数据源，处理业务</h3>
<pre><code class="language-java">package com.mobai.osj.system.service.impl;

import com.baomidou.dynamic.datasource.annotation.DS;
import com.mobai.osj.system.service.BusinessService;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

/**
 * @author mxc
 * @date 2022-01-06
 * @description 跨服务实现层
 */
@AllArgsConstructor
@Service
public class BusinessServiceImpl implements BusinessService {

    final private DataSource datasource;

    @DS(&quot;OSJ_PRO&quot;)
    @Override
    public ResultSet selectForJapanBigPromotion(String sql) throws SQLException {
        Connection connection = datasource.getConnection();
        Statement statement = connection.prepareStatement(sql);
        return statement.executeQuery(sql);
    }
}

</code></pre>
<br/>
<h3 id="数据库数据源配置">数据库数据源配置</h3>
<pre><code class="language-sql">CREATE TABLE `sys_data_source` (
  `id` varchar(36) NOT NULL,
  `code` varchar(100) DEFAULT NULL COMMENT '数据源编码',
  `name` varchar(100) DEFAULT NULL COMMENT '数据源名称',
  `remark` varchar(200) DEFAULT NULL COMMENT '备注',
  `db_type` varchar(10) DEFAULT NULL COMMENT '数据库类型',
  `db_driver` varchar(100) DEFAULT NULL COMMENT '驱动类',
  `db_url` varchar(500) DEFAULT NULL COMMENT '数据源地址',
  `db_name` varchar(100) DEFAULT NULL COMMENT '数据库名称',
  `db_username` varchar(100) DEFAULT NULL COMMENT '用户名',
  `db_password` varchar(100) DEFAULT NULL COMMENT '密码',
  `create_by` varchar(50) DEFAULT NULL COMMENT '创建人',
  `create_time` datetime DEFAULT NULL COMMENT '创建日期',
  `update_by` varchar(50) DEFAULT NULL COMMENT '更新人',
  `update_time` datetime DEFAULT NULL COMMENT '更新日期',
  `sys_org_code` varchar(64) DEFAULT NULL COMMENT '所属部门',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE KEY `sys_data_source_code_uni` (`code`) USING BTREE,
  UNIQUE KEY `uk_sdc_rule_code` (`code`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并发编程（一）：线程池]]></title>
        <id>https://2321079146.github.io/mobai.github.io/post/ce-shi-bai-du-kong-jian-shi-fou-ke-yong/</id>
        <link href="https://2321079146.github.io/mobai.github.io/post/ce-shi-bai-du-kong-jian-shi-fou-ke-yong/">
        </link>
        <updated>2022-01-20T07:37:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1线程池的好处">1.线程池的好处</h2>
<p>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p>
<ul>
<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的销毁</li>
<li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<br/>
<h2 id="2executor">2.Executor</h2>
<h3 id="21简介">2.1简介</h3>
<p>Executor 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，Executor 框架让并发编程变得更加简单。有助于避免this逃逸。</p>
<blockquote>
<p>this逃逸：是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误</p>
</blockquote>
<h3 id="22executor框架结构主要由三大部分组成">2.2Executor框架结构（主要由三大部分组成）</h3>
<p>1**.任务（Runnable/Callable)**</p>
<p><strong>2.任务的执行（Executor)</strong></p>
<pre><code>这里重点类是ThreadPoolExecutor 和 ScheduledThreadPoolExecutor
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333083829.png" alt="" loading="lazy"></figure>
<p><strong>3.异步计算结果（Future)</strong></p>
<p>Future 接口以及 Future 接口的实现类 FutureTask 类都可以代表异步计算的结果。</p>
<p>当我们把 Runnable接口 或 Callable 接口 的实现类提交给 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。（调用 submit() 方法时会返回一个 FutureTask 对象）</p>
<h3 id="23executor框架的使用示意图">2.3Executor框架的使用示意图</h3>
<figure data-type="image" tabindex="2"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333102632.png" alt="" loading="lazy"></figure>
<ol>
<li>主线程首先要创建实现 Runnable 或者 Callable 接口的任务对象。</li>
<li>把创建完成的实现 Runnable/Callable接口的 对象直接交给 ExecutorService 执行: ExecutorService.execute（Runnable command））或者也可以把 Runnable 对象或Callable 对象提交给 ExecutorService 执行（ExecutorService.submit（Runnable task）或 ExecutorService.submit（Callable <T> task））。</li>
<li>如果执行 ExecutorService.submit（…），ExecutorService 将返回一个实现Future接口的对象（我们刚刚也提到过了执行 execute()方法和 submit()方法的区别，submit()会返回一个 FutureTask 对象）。由于 FutureTask 实现了 Runnable，我们也可以创建 FutureTask，然后直接交给 ExecutorService 执行。</li>
<li>最后，主线程可以执行 FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。</li>
</ol>
<p><strong>注：future:集Runnable、Callable、Future于一身,future.get()会造成当前线程的阻塞，在ExecutorService框架中，由于使用线程池，所以Runnable与Callable实例都当做任务看待，而不会当做“线程”看待。调用时如果任务还未执行完就会阻塞直到任务完成；当然我们也可以调用get的另一重载版本get(long timeout, TimeUnit unit)，当阻塞时会等待指定的时间，如果时间到而任务还未完成，那么就会抛出TimeoutException</strong></p>
<br/>
<h2 id="3重要threadpoolexecutor">3.【重要】ThreadPoolExecutor</h2>
<h3 id="31七大核心参数">3.1七大核心参数</h3>
<p>源码截图</p>
<figure data-type="image" tabindex="3"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333116958.png" alt="" loading="lazy"></figure>
<ol>
<li>corePoolSize：线程池中最小运行的数量</li>
<li>workQueue：&gt; corePoolSize会放入队列中</li>
<li>maximumPoolSize ：队列满了，可以同时运行的线程数量变为最大线程数</li>
<li>handler ：饱和策略/拒绝策略
<ol>
<li>
<p>ThreadPoolExecutor.AbortPolicy（默认）：抛出 RejectedExecutionException来拒绝新任务的处理。<br>
【银行满了，还有人进来，不处理这个人，抛出异常】</p>
</li>
<li>
<p>ThreadPoolExecutor.CallerRunsPolicy ：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。<br>
【哪来的去哪里】只要撑不死，就往死里吃，说是提供了可伸缩的队列，没看着<br>
<img src="https://2321079146.github.io/mobai.github.io//post-images/1643333166082.png" alt="" loading="lazy"></p>
</li>
<li>
<p>ThreadPoolExecutor.DiscardPolicy ：不处理新任务，直接丢弃掉。<br>
【不会抛出异常】</p>
</li>
<li>
<p>ThreadPoolExecutor.DiscardOldestPolicy ：此策略将丢弃最早的未处理的任务请求。</p>
<pre><code>  【队列满了，尝试和最早的竞争，也不会抛出异常】
</code></pre>
</li>
</ol>
</li>
</ol>
<h3 id="32注意">3.2注意</h3>
<blockquote>
<p>在《阿里巴巴 Java 开发手册》“并发处理”这一章节，明确指出线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>
</blockquote>
<p>因为通过FixedThreadPool 、SingleThreadExecutor 、CachedThreadPool 、ScheduledThreadPool<br>
这样创建线程池，很容易导致oom<br>
<img src="https://2321079146.github.io/mobai.github.io//post-images/1643333200120.png" alt="" loading="lazy"></p>
<br/>
<br/>
<h2 id="4建议不同业务使用不同的线程池">4.建议不同业务使用不同的线程池</h2>
<p>真实案例：若有父任务和子任务都使用一个线程池，那么当父任务耗尽了线程池的资源，而子任务无法争取到线程资源，但是父任务需要等到子任务完成后才能结束让出线程资源，则会造成死锁。</p>
<br/>
<h2 id="5线程池命名">5.线程池命名</h2>
<p>若是默认的线程池名称，没有任何的业务意义，若出现了业务问题，则不好定位问题</p>
<ol>
<li>
<p>.利用 guava 的 ThreadFactoryBuilder</p>
<pre><code class="language-java">ThreadFactory threadFactory = new ThreadFactoryBuilder()
                        .setNameFormat(threadNamePrefix + &quot;-%d&quot;)
                        .setDaemon(true).build();
ExecutorService threadPool = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, TimeUnit.MINUTES, workQueue, threadFactory)
</code></pre>
</li>
<li>
<p>自定义</p>
<pre><code class="language-java">import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;
/**
 * 线程工厂，它设置线程名称，有利于我们定位问题。
 */
public final class NamingThreadFactory implements ThreadFactory {

    private final AtomicInteger threadNum = new AtomicInteger();
    private final ThreadFactory delegate;
    private final String name;

    /**
     * 创建一个带名字的线程池生产工厂
     */
    public NamingThreadFactory(ThreadFactory delegate, String name) {
        this.delegate = delegate;
        this.name = name; // TODO consider uniquifying this
    }

    @Override 
    public Thread newThread(Runnable r) {
        Thread t = delegate.newThread(r);
        t.setName(name + &quot; [#&quot; + threadNum.incrementAndGet() + &quot;]&quot;);
        return t;
    }

}

</code></pre>
</li>
</ol>
<br/>
<h2 id="6正确配置线程池参数">6.正确配置线程池参数</h2>
<h3 id="61线程池执行示意图">6.1线程池执行示意图</h3>
<figure data-type="image" tabindex="4"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333248329.png" alt="" loading="lazy"></figure>
<h3 id="62线程池参数动态配置">6.2线程池参数动态配置</h3>
<p><strong>6.2.1 业务场景</strong></p>
<p>因为线程的参数设定需要对业务和线程的经验作为支撑，所以很可能出现参数过大或者过小的情况，导致业务异常，美团的解决方案是动态改变线程池设定的参数。</p>
<p><strong>6.2.2 问题</strong></p>
<ol>
<li>如何才能动态设定线程池的参数呢？</li>
<li>若进行线程池的替换，而原本的线程池中已经存在了任务，那么怎么才能做到无缝丝滑切换呢？</li>
</ol>
<p><strong>6.2.3 之前的解决方案</strong></p>
<p>先判断是CPU密集型还是IO密集型</p>
<ol>
<li>CPU密集型 = 核心数 + 1<br>
这个1类似于一个备份线程</li>
<li>IO密集型【计算公式】<br>
<img src="https://2321079146.github.io/mobai.github.io//post-images/1643333261128.png" alt="" loading="lazy"></li>
</ol>
<br/>
<hr>
<p>接下来是现有的方案：动态参数配置</p>
<p><strong>6.2.4 动态更新的工作原理</strong></p>
<pre><code>*查看源码就会发现，corePoolSize和maximumPoolSize都是可以动态调整的*

在线程运行时，重新赋值corePoolSize之后的流程：
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333278513.png" alt="" loading="lazy"></figure>
<br/>
<p><strong>6.2.5 动态设置的注意点</strong></p>
<pre><code>问题1：调整后可能会出现调整无效的情况，若工作线程数大于最大线程数
</code></pre>
<ol>
<li>
<p>创建新的工作线程 worker，然后工作线程数进行加一操作。</p>
</li>
<li>
<p>运行创建的工作线程 worker，开始获取任务 task。</p>
</li>
<li>
<p>工作线程数量大于最大线程数，对工作线程数进行减一操作。返回 null，即没有获取到 task。</p>
</li>
<li>
<p>清理该任务，流程结束。</p>
<p><em>这样一加一减，所以真正在执行任务的工作线程数的数量一直没有发生变化，也就是最大线程数。设置核心线程数的时候，同时设置最大线			程数即可。其实可以把二者设置为相同的值：</em>、</p>
</li>
</ol>
<br/>
<pre><code>问题2：如果调整之后把活动线程数设置的值太大了，岂不是业务低峰期我们还需要人工把值调的小一点？

当 allowCoreThreadTimeOut 参数设置为 true 的时候，核心线程在空闲了 keepAliveTime 的时间后也会被回收的，相当于线程池自动给你动态修改了。
</code></pre>
<br/>
<pre><code>问题3：如何动态的修改队列长度

美团解决自定义队列**ResizableCapacityLinkedBlockIngQueue**，可以自定义长度
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://2321079146.github.io/mobai.github.io//post-images/1643333297882.png" alt="" loading="lazy"></figure>
<br/>
<p><strong>6.2.6  线程池创建问题</strong></p>
<pre><code>问题1：线程池被创建后里面有线程吗？如果没有的话，你知道有什么方法对线程池进行预热吗？
</code></pre>
<ol>
<li>**prestartAllCoreThreads **全部启动</li>
<li>**prestartCoreThread **仅启动一个</li>
</ol>
<br/>
<pre><code>问题2：核心线程数会被回收吗？需要什么设置？

可，调用**allowCoreThreadTimeOut**设置为 rue
</code></pre>
<br/>
<p><strong>6.2.7 代码示例</strong></p>
<pre><code class="language-java">package com.mobai.thread;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * @author mxc
 * @date 2022-01-27
 * @description 正常创建线程池示例
 */
public class ThreadPoolDemo {

    public static void main(String[] args) throws InterruptedException {
        long start = System.currentTimeMillis();
        dynamicModifyExector();
        System.out.println(&quot;一共使用时间&quot; + (System.currentTimeMillis() - start));
    }

    private static void dynamicModifyExector() throws InterruptedException {

        ThreadPoolExecutor executor = buildThreadPoolExecutor();
        for (int i = 0; i &lt; 15; i++) {
            executor.submit(() -&gt; {
                threadPoolStatus(executor, &quot;创建任务&quot;);
                try{
                    TimeUnit.SECONDS.sleep(10);
                }catch (Exception e){
                    e.printStackTrace();
                }
            });
        }

        threadPoolStatus(executor, &quot;改变之前&quot;);
        executor.setCorePoolSize(10);
        executor.setMaximumPoolSize(10);
        // 启动所有的核心线程数
        executor.prestartCoreThread();
        threadPoolStatus(executor, &quot;改变之后&quot;);
        Thread.currentThread().join();
    }

    private static ThreadPoolExecutor buildThreadPoolExecutor() {
        return new ThreadPoolExecutor(2
                , 5
                , 60
                , TimeUnit.SECONDS
                , new LinkedBlockingQueue&lt;&gt;(10)
                , new NameThreadFactory(&quot;自定义线程池&quot;));
    }


    /**
     * 打印线程池状态
     * @param executor 线程池
     * @param name 名称
     */
    public static void threadPoolStatus(ThreadPoolExecutor executor, String name){
        BlockingQueue&lt;Runnable&gt; queue = executor.getQueue();

        System.out.println(Thread.currentThread().getName() + &quot;-&quot; + name + &quot;-&quot; +
                &quot; 核心线程数：&quot; + executor.getCorePoolSize() +
                &quot; 活动线程数：&quot; + executor.getActiveCount() +
                &quot; 最大线程数：&quot; + executor.getMaximumPoolSize() +
                &quot; 线程池活跃度：&quot; + divide(executor.getActiveCount(), executor.getMaximumPoolSize()) +
                &quot; 任务完成数：&quot; + executor.getCompletedTaskCount() +
                &quot; 队列大小：&quot; + (queue.size() + queue.remainingCapacity()) +
                &quot; 当前排队线程数：&quot; + queue.size() +
                &quot; 队列剩余大小：&quot; + queue.remainingCapacity() +
                &quot; 队列使用度：&quot; + (divide(queue.size(), queue.size() + queue.remainingCapacity()))
        );
    }

    /**
     * 保留两位小数
     * @param num1 参数1
     * @param num2 参数2
     * @return 计算结果
     */
    private static String divide(int num1, int num2){
        return String.format(&quot;%1.2f%%&quot;, Double.parseDouble(num1 + &quot;&quot;) / Double.parseDouble(num2 + &quot;&quot;) * 100);
    }
}

</code></pre>
]]></content>
    </entry>
</feed>